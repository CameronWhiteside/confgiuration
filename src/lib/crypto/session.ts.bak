/**
 * Session-based encryption using X25519 ECDH + AES-GCM
 *
 * Flow:
 * 1. Client requests a new session â†’ Server generates keypair, returns publicKey + sessionId
 * 2. Client generates its own keypair, derives shared secret using server's publicKey
 * 3. Client encrypts payload with shared secret, sends encrypted data + client publicKey
 * 4. Server derives same shared secret using client's publicKey + server's privateKey
 * 5. Server decrypts payload, processes, encrypts response with same shared secret
 *
 * This provides forward secrecy per-session and ensures payloads are encrypted
 * beyond just HTTPS transport encryption.
 */

// @ts-expect-error - module resolution issue with noble/curves
import { x25519 } from "@noble/curves/ed25519";

export interface Session {
	id: string;
	serverPublicKey: Uint8Array;
	serverPrivateKey: Uint8Array;
	createdAt: number;
	expiresAt: number;
}

export interface SessionPublic {
	sessionId: string;
	publicKey: string; // hex encoded
}

/**
 * Generate cryptographically secure random bytes
 */
function getRandomBytes(length: number): Uint8Array {
	const bytes = new Uint8Array(length);
	crypto.getRandomValues(bytes);
	return bytes;
}

/**
 * Generate a new session with X25519 keypair
 */
export function createSession(ttlMs: number = 24 * 60 * 60 * 1000): Session {
	const privateKey = x25519.utils.randomPrivateKey();
	const publicKey = x25519.getPublicKey(privateKey);
	const now = Date.now();

	return {
		id: generateSessionId(),
		serverPublicKey: publicKey,
		serverPrivateKey: privateKey,
		createdAt: now,
		expiresAt: now + ttlMs,
	};
}

/**
 * Get public session data to send to client
 */
export function getSessionPublic(session: Session): SessionPublic {
	return {
		sessionId: session.id,
		publicKey: uint8ArrayToHex(session.serverPublicKey),
	};
}

/**
 * Derive shared secret from ECDH
 */
export function deriveSharedSecret(
	privateKey: Uint8Array,
	peerPublicKey: Uint8Array
): Uint8Array {
	return x25519.getSharedSecret(privateKey, peerPublicKey);
}

/**
 * Encrypt data using AES-GCM with the shared secret
 */
export async function encrypt(
	data: string,
	sharedSecret: Uint8Array
): Promise<{ ciphertext: string; iv: string }> {
	const encoder = new TextEncoder();
	const dataBytes = encoder.encode(data);

	// Use first 32 bytes of shared secret as AES key
	const keyMaterial = sharedSecret.slice(0, 32);
	const key = await crypto.subtle.importKey(
		"raw",
		keyMaterial,
		{ name: "AES-GCM" },
		false,
		["encrypt"]
	);

	// Generate random IV (12 bytes for AES-GCM)
	const iv = getRandomBytes(12);

	const ciphertext = await crypto.subtle.encrypt(
		{ name: "AES-GCM", iv },
		key,
		dataBytes
	);

	return {
		ciphertext: uint8ArrayToHex(new Uint8Array(ciphertext)),
		iv: uint8ArrayToHex(iv),
	};
}

/**
 * Decrypt data using AES-GCM with the shared secret
 */
export async function decrypt(
	ciphertext: string,
	iv: string,
	sharedSecret: Uint8Array
): Promise<string> {
	const keyMaterial = sharedSecret.slice(0, 32);
	const key = await crypto.subtle.importKey(
		"raw",
		keyMaterial,
		{ name: "AES-GCM" },
		false,
		["decrypt"]
	);

	const ivBytes = hexToUint8Array(iv);
	const ciphertextBytes = hexToUint8Array(ciphertext);

	const decrypted = await crypto.subtle.decrypt(
		{ name: "AES-GCM", iv: ivBytes },
		key,
		ciphertextBytes
	);

	const decoder = new TextDecoder();
	return decoder.decode(decrypted);
}

/**
 * Generate a random session ID
 */
function generateSessionId(): string {
	const bytes = getRandomBytes(16);
	return uint8ArrayToHex(bytes);
}

/**
 * Convert Uint8Array to hex string
 */
export function uint8ArrayToHex(bytes: Uint8Array): string {
	return Array.from(bytes)
		.map((b) => b.toString(16).padStart(2, "0"))
		.join("");
}

/**
 * Convert hex string to Uint8Array
 */
export function hexToUint8Array(hex: string): Uint8Array {
	const bytes = new Uint8Array(hex.length / 2);
	for (let i = 0; i < hex.length; i += 2) {
		bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
	}
	return bytes;
}

/**
 * Check if a session has expired
 */
export function isSessionExpired(session: Session): boolean {
	return Date.now() > session.expiresAt;
}

/**
 * Serialize session for storage (e.g., KV)
 */
export function serializeSession(session: Session): string {
	return JSON.stringify({
		id: session.id,
		serverPublicKey: uint8ArrayToHex(session.serverPublicKey),
		serverPrivateKey: uint8ArrayToHex(session.serverPrivateKey),
		createdAt: session.createdAt,
		expiresAt: session.expiresAt,
	});
}

/**
 * Deserialize session from storage
 */
export function deserializeSession(data: string): Session {
	const parsed = JSON.parse(data);
	return {
		id: parsed.id,
		serverPublicKey: hexToUint8Array(parsed.serverPublicKey),
		serverPrivateKey: hexToUint8Array(parsed.serverPrivateKey),
		createdAt: parsed.createdAt,
		expiresAt: parsed.expiresAt,
	};
}
